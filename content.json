{"meta":{"title":"4eay7_lab > blog","subtitle":"a lab notebook","description":"a lab notebook","author":"eregerm","url":"https://4eay7lab.com","root":"/"},"pages":[{"title":"friends","date":"2020-10-26T09:20:57.314Z","updated":"2020-10-26T09:20:57.314Z","comments":false,"path":"friends/index.html","permalink":"https://4eay7lab.com/friends/index.html","excerpt":"","text":"friend A miri chen YuweiZhao Ye Kehuai xgsteins Brethland 0xfaner Yuhi"},{"title":"about","date":"2020-10-26T07:31:31.408Z","updated":"2020-10-26T07:31:31.408Z","comments":false,"path":"about/index.html","permalink":"https://4eay7lab.com/about/index.html","excerpt":"","text":"ERror Experiment GEneRates eregerM nickname：eregerm location：njupt e-mail：eregerm@outlook.com"},{"title":"","date":"2020-10-26T07:31:31.408Z","updated":"2020-10-26T07:31:31.408Z","comments":false,"path":"categories/index.html","permalink":"https://4eay7lab.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-26T07:31:31.597Z","updated":"2020-10-26T07:31:31.597Z","comments":false,"path":"tags/index.html","permalink":"https://4eay7lab.com/tags/index.html","excerpt":"","text":""},{"title":"today","date":"2019-12-30T19:09:07.000Z","updated":"2020-10-26T07:31:31.598Z","comments":true,"path":"today/index.html","permalink":"https://4eay7lab.com/today/index.html","excerpt":"","text":"today’s recommendation pixiv id: 67885191"}],"posts":[{"title":"afa记录","slug":"afa-log","date":"2019-12-23T14:49:07.000Z","updated":"2020-10-26T07:31:31.404Z","comments":true,"path":"2019/12/23/afa-log/","link":"","permalink":"https://4eay7lab.com/2019/12/23/afa-log/","excerpt":"","text":"记录弱校蒟蒻icpcer被acm荒废（雾）的一年半（从大二到大三上）。 以下比赛只列举比较有意义的国赛。 摸鱼记录这之前大学前大学之前没接触过oi。 校科协大一军训时听了校科协宣讲会后才知道acm的。 听介绍，做面试题，直接被劝退了。 大一上并没有去学它。 a协大一寒假看了《aha算法》（适合0基础看，最通俗易懂地讲解最基础的算法），目的只是了解算法知识，不是打acm。 大一下去玩了一下vijos（切水题都困难）。 想通过校赛，测试一下自己的实力。。。 结果xjb搞就一等奖了。 正好a协在招人。。。 因此进了a协。 大一到大二暑假随便组了一个队伍（队友：mr、xxy），开始了暑假集训。 日常afk自学。。。 从0开始，学到了许多算法。。。 去做了luogu试炼场，依然切水题都困难。 学习主要看书看博客，不怎么刷题（一暑假白给）。 大二上icpc南京区域赛 铁（倒数）（1题）第1次打现场赛，算是学校送的体验名额。 这场我没认真打。 热身赛。好像爆零了。 正式赛。签到题A题是博弈论、找规律，队友全程找规律、猜规律，全程wa，我想了想就放弃了，去开别的题，结果也没开出来。最后队友终于把A题a了，也没多少时间开其它题了。 丢人退出赛场。 2018icpc南京区域赛 打完心态崩了。。。 开始了xjb刷题，决心之后一定要拿个牌子。 大二下开了oi_solutions repo，记录有意义的题目。因为觉得自己实力不够，所以记录的基本银区题或模板题。 cccc 全国团队二等奖这场跟出去玩似的，最后分数在校内rk12/30。 这之后放假看wf直播，受到了一些激励。 icpc西安邀请赛 银（尾）（5题）校内队伍选拔获得的名额。 第2次现场赛。 打之前还是很慌的，毕竟之前打了铁。 因为是周六出发的，所以没打热身赛。 正式赛。A题是水题，直接1a。队友开L题。我开了M题，当场想到的是最短路，1a（后来知道很多队都是bfs的）。队友L题没找到规律，我打了个表，过于着急乱交了2发，wa，然后把表给队友看，xxy看出规律才a了。然后一起开C题，讨论了一下，想了一个分类讨论计算的方法，我写完，样例没过，看了clarification才知道样例错了，然后1a。然后开始开D题，xxy讲了一下题意，我想到一个并查集+01背包的解法，然后写完交了一发re了，检查后发现数组存不下，改了一下，封榜的时候a了。最后1h开始afk划水。。。 最后摸了个银（银区基本5题，然而我们罚时太多了）。 2019icpc西安邀请赛 蓝桥杯c/c++ b组 国二做填空题心态崩了，后面编程题没有认真做。 全程就当旅游。。。 大二到大三暑假原队友准备考研（就业），退役了，于是我又随便重新组了一个队伍（队友：源妹、hxy）。 同班同学都去鹅厂实习了。。。其实这时已经不是很想打了。。。心理上最艰难的暑假，一直自闭，想要放弃。。但还是坚持了下去。。。 经历了银川网络赛，对icpc有些失望。 大三上icpc南京区域赛 铜（首）（4题）按网络赛排名给了1个名额（南昌网络赛差点罚时就出线了，有点可惜）。 据说这场是诸神之战，大概因为银川的事情，强队都来玩了。。慌的一批。 不过队友都比较认真，比赛前几周练了几场前几年的区域赛，前几天做了充足的讨论和准备，打印了一堆板子。。。 热身赛。交了一道水题就开始afk了，机器挂了几次，隔壁队伍都快ak了。 正式赛。队友开A题，我开K题。K题我想到一个二分的解法，先开始写了。队友找A题规律，写了一下，1a。我继续写K，大概1h的时候测试完，1a。然后源妹来写C题，我和hxy看别的题，大概又过去了1h，询问情况，发现读错题了，此时快被挤出铜区了，全队开始一起想C题，hxy想到入度和出度的关系，我看了一会，想出一个dp，需要先用dfs把长度小于4的个数先算出来，然后1a。快封榜了，一起开H题，hxy之前交了1发，wa，讨论很久，还是1发wa，最后我xjb想到1 0 0的情况答案是0，改了一下第一次的提交，a了，此时还剩十几分钟，开始afk。。。 罚时少了可以银，有点可惜。 一打完就赶紧溜回去汇编期末考试了。。。 2019icpc南京区域赛 从此自认退役，想着再也不打。。。 已放弃蓝桥杯。 oi_solutions repo停止更新。 准备学习面试。 这之后去玩了一把校赛，个人赛，然后被给重组名额去ec final，于是重组了一个队伍（队友：zyj、qjy），练了2场水题（只有2周时间准备），不熟悉队友，团队配合也不是很熟，不适应环境，我也没尽全力打，摸鱼打铁 gg （2题）。 得 拿到了牌子（x 英语阅读理解能力（程序员基本素养） 思维能力（太棒了，确实变好了（x）） 竞赛用算法和数据结构（狭隘而较深的算法知识，在工程中基本没用。。。） 人力debug程度的能力 积极的心态、集中的意识、自信沉着的品质（目前看来它的有无确实会影响到结果） 认识了dalao们和女装dalao们（打acm的感觉像回家一样，在a协里的感觉比家里感觉好多了！里面个个都是人才，说话又好听，我超喜欢里面的！） 功利上来说，保研考研有点帮助（主要加能力分，虽然我决定不读研），工作可过简历关？（玄学，主要看脸。以及据说这样做也有可能坑自己，算法题不出或者变难） 太棒了，学到许多 失 项目（虽然有，但都是玩具） 实习（正在找） 广阔的cs知识（似乎大多数书籍都是大一看的，之后一年半就开始刷题日常。。。） 总结一年半，在3个不同的队伍打过现场赛。。。 没有抱到大腿，完全靠自己和队友从0开始。 成果：1银1铜（rk100+） 靠着队友合作以及一部分的运气，最好时是区域赛铜首银尾的水平。。。（毕竟是5小时被卡easy题的蒟蒻qwq） 一言以蔽之，比较菜，投入时间很多，收效却甚微。 （主要学习方法的问题，入坑后的半年多走了不少弯路） 坑 acm是个大坑，并没有非常热爱，想要金牌大概还需要一年，wf更不可能，溜了溜了。。。希望校队dalao们继续加油！~ 经验作为一个最好rk100+的蒟蒻，来传授经验，有点丢人。 然而毕竟一年半了，有很多感想，所以觉得还是有必要说一下自己的建议，希望学弟学妹能少走弯路。 以下内容适合萌新，不适合dalao。 劝退总的来说我不建议打。acm像游戏，所以不建议沉迷游戏（雾）。 对于考虑打acm的同学。 首先要认清自己的能力，找准定位。以前有oi经历，并且打得好的，或者，到大学才开始打的，有天赋并且愿意付出许多的，可以打。若是不擅长，打了一年还是不擅长，那还是早点放弃，专注于其他竞赛或者实际工程项目更好。 接触acm后，请确定自己是否真正热爱acm。若只是为了功利的目的，建议放弃。 如果学校不是强校而是弱校，也要再三考虑，一般弱校需要付出更多个人的努力。 最后，打acm会越打越穷，想要奖金建议ctf（雾）。 准备如果已经准备打了。 想要打好xcpc，2种策略。 1人切题带队友，队友打辅助对于蒟蒻来说不行，不常见，也不建议自己不努力只想着队友带，3人都这亚子就gg了。（w 注重团队配合这是正常的方案。 首先要找队友，最好找到同年级的志同道合的同学一起玩。最好大一就开始，一起练习和讨论。。。（不要像我一样大二才开始，还一直重组）对于学妹，是否组女队，我建议如果找不到好的队友当然不建议强行组，找志同道合的组就好了（女队唯一优势是最佳女队（这个一般就别想了，除非没有强队或者你们是强队）和参加女生赛（有点水））。 组好队了，开始分题。所有队员都要练习思维能力，最好都要会做不需要算法的思维水题。然后开始专题分工，一个专题至少需要2人进行深入研究和练习，将知识点全部覆盖。学习打acm最有效的方法是刷题，以题来学习知识。一定不要只看不练。（我主要刷的蓝书习题，以及loj和kuangbin专题） 需要经常训练，包括个人训练和组队训练。（建议自己拉题做，有针对性的。。我们主要练历年真题，以及hdu多校） 除此之外，多打cf的比赛，练习实战切题能力。rating要努力到1900+，这样基本就稳银了（当然我还没有qwq）。 比赛xcpc比赛都是3个人用1台电脑。 首先，3人对于题目的讨论要活跃，表意明确。 其次，不经充分思考就编写的现象很常见，所以建议在上机敲代码前多思考，以提高协作效率。 虽然正式比赛可以使用模板，但是平时不建议依赖板子，比赛也不建议。其实这个自己敲多了也就会了。 在交题前注意检查常见问题，小心罚时。 最后，最重要的3个人都要有决心，不要轻易放弃。 不出锅，手速快，拿个铜没问题，运气好摸个银。 然后关于如何冲金，我没有的，这个问dalao们吧（qwq 其它 the best or nothing 既然进来打了，就不要划水了，努力争取，不要留下遗憾，否则最后可能浪费了几年时间而一无所得。 遗产我的题解 推荐的板子 推荐的入门指南 推荐的经验总结 推荐的wiki 顺便推荐一下noj 劝退1 劝退2 劝退3 附2019-12-28最近看到一篇和我总结的差不多的总结（推荐读一下姥姥的信） 2019-12-30更新了一些内容…_(:з」∠)_","categories":[{"name":"其它","slug":"其它","permalink":"https://4eay7lab.com/categories/其它/"}],"tags":[{"name":"acm","slug":"acm","permalink":"https://4eay7lab.com/tags/acm/"},{"name":"记录","slug":"记录","permalink":"https://4eay7lab.com/tags/记录/"},{"name":"总结","slug":"总结","permalink":"https://4eay7lab.com/tags/总结/"},{"name":"吐槽","slug":"吐槽","permalink":"https://4eay7lab.com/tags/吐槽/"}]},{"title":"sicp ch1-3 笔记","slug":"sicp-123","date":"2019-08-04T16:00:00.000Z","updated":"2020-10-26T07:31:31.408Z","comments":true,"path":"2019/08/05/sicp-123/","link":"","permalink":"https://4eay7lab.com/2019/08/05/sicp-123/","excerpt":"","text":"介绍sicp是编程方面的入门课程。 有关sicp的资源和评价很多，在此不多介绍。 一些相关资源链接： 书 SICP 解题集 scheme tutorial ch1 用过程构建抽象概述计算过程（computational process）过程是计算机中抽象的存在，能够产生其他抽象的东西——数据（data）。过程的演变被程序（program）指导，程序由编程语言（programming languages）中的符号表达组成。程序可能有错误，需要debug。 使用lisp编程lisp（LISt Processing的缩写）发明于20世纪50年代后期，被用于计算模型的某种逻辑表达式（称为递归方程（recursion equations））的使用的推理的形式。lisp有很多方言，这里使用scheme。 lisp不是主流语言，使用的原因是，它拥有独特的特点，使它成为学习重要的编程结构和数据结构以及和支持它们的语言特点相关联的极好的媒介。最重要的是，lisp的过程的描述（称为procedure）本身可以被作为lisp数据来表达或操作。 编程的要素强大的编程语言不仅是指导计算机执行任务的方法，而且能作为组织思想和过程的框架。 强大的语言的3个机制： 基础表达式（primitive expressions）：最简单的实体 组合的方法（means of combination）：使用简单的元素构造复合元素 抽象的方法（means of abstraction）：组合元素被作为单元命名和操作 在编程中，我们处理2类元素：过程和数据。数据是我们想要操作的东西。过程是操作数据的规则的描述。任何强大的程序设计语言必须能表述基本的数据和过程，还需要提供对过程和数据组合和抽象的方法。 第1章只处理最简单的数值数据，以关注构建过程的规则。 以下大概是scheme的简单使用，有的不展开。 表达式一些与scheme解释器交互的实例，输入表达式以求值（evaluate）。包括基础表达式、组合式（combinations）。 命名和环境程序设计语言需要提供一种通过名字去使用计算对象的方式。名字标识符被称为变量，它的值是对应的对象。 好处是，每次使用计算对象时，不需要重复写出细节，能逐步创建名字-对象关联，采用递增的方式开发和调试程序。 解释器实现关联后又能提取这些值的存储被称为环境（environment）。 组合式的求值组合式求值的规则（不能处理特殊形式（specialforms））： 对子表达式求值 将最左子表达式的值（过程，运算符）应用于相应的实际参数，实际参数是其它子表达式的值（运算对象） 这一规则的应用是递归的。可以简洁地描述嵌套的情况。可以采用树的形式表示组合式求值过程，一个带分支的节点表示某个组合式，由它出发的分支对应于组合式的运算符和运算对象，叶子节点表示基本运算符或数值，运算对象的值向上穿行。值向上穿行的求值形式是更一般的计算过程——树形积累（tree accumulation）的例子。 12(* (+ 2 (* 4 6)) (+ 3 5 7)) 表示每个子组合式的值的树 复合过程我们已经看到了lisp里的某些元素，它们必然也会出现在任何一种强大的程序设计语言里。包括： 数和算术运算是基本的数据和过程。 组合式的嵌套提供了一种组织起多个操作的方法。 定义是一种受限的抽象手段，它为名字关联相应的值。 过程定义为复合操作提供名字，以后可以将其作为一个单元使用。 过程应用的代换模型（substitution model）求值一个组合式，解释器完全按照上面的组合式求值的规则求值。 对于基本运算符，解释器已经做好。对于复合过程，计算过程是，用实参取代形参，对过程求值。这种计算过程被称为过程应用的代换模型。 置换的目的是为了帮助我们理解程序应用，并不是提供解译器如何真实工作的描述。典型的解译器并不通过操作程序的文本来置换形式参数的值执行程序应用。之后会介绍一系列逐渐复杂的模型来解释解译器如何工作的。 应用序（applicative order）先对运算符和各个运算对象求值，然后将得到的过程应用于得到的实参。 lisp采用应用序。 正则序（normal order）先用运算对象表达式代换形参，直到一个只包含基本运算符的表达式，然后再求值。 条件表达式和谓词（predicates）lisp有分情况分析的特殊形式。 谓词指返回真或假的过程，或求真或假的表达式。 当作黑盒抽象的过程对于一个问题，可以自然地分解为若干子问题。分解的重要性在于每一个过程完成了一件清楚表明的工作，使它们可被用作定义其它过程的模块。模块可以看作黑箱，只关注结果，无需关注细节实现。它是一个过程抽象。 过程（procedures）和他们产生的过程（processes）看清不同种类的过程会产生什么计算过程，才能构造可靠的程序。 以下给出一些过程演化的典型模式。 线性递归（linear recursion）过程调用完自身（一次调用）后调用了其它过程(会被推迟执行形成链条)。 展开阶段，计算过程构造了推迟进行的操作所形成的链条。收缩阶段，运算实际执行。推迟进行需要保存和链条长度成正比的信息(有一些隐含信息)。 1234(define (factorial n) (if (= n 1) 1 (* n (factorial (- n 1))))) 线性递归 线性迭代（linear iteration）过程调用完自身后没有调用其它过程，被称为尾递归（tail-recursive）。 没有展开和收缩的过程。计算过程的状态可用固定数量状态变量描述。 123456789(define (factorial n) (fact-iter 1 1 n))(define (fact-iter product counter max-count) (if (&gt; counter max-count) product (fact-iter (* counter product) (+ counter 1) max-count))) 线性迭代 在大部分其他语言中(比如C)，只要是语法是递归的，计算过程就是递归的，循环需要使用循环结构(for/while)实现。而lisp中，尾递归计算过程是迭代。 树形递归（tree recursion）过程调用完自身（多次调用）后调用了其它过程。 12345(define (fib n) (cond ((= n 0) 0) ((= n 1) 1) (else (+ (fib (- n 1)) (fib (- n 2)))))) 树形递归 增长的阶讲了时空复杂度。。 举了很多例子。。。 使用高阶过程（higher-order procedures）制定抽象高阶过程是过程作为过程的参数或返回值的过程。 模式作为一个概念表达时，高阶过程是有力的抽象机制。 过程作为参数（arguments）比如，要实现sigma的方法（或概念？）。 \\sum_{n=a}^{b}f(n)=f(a)+...+f(b)12345(define (sum term a next b) (if (&gt; a b) 0 (+ (term a) (sum term (next a) next b)))) 使用lambda构建过程lambda用于生成匿名函数。用于定义一些简单的不需要名字的过程。 比如，实现积分： 123456(define (integral f a b dx) (* (sum f (+ a (/ dx 2.0)) (lambda (x) (+ x dx)) b) dx)) 作为通用方法的过程讲了几个例子。。。 作为返回值（returned values）的过程比如，表达平均阻尼的思想： 12(define (average-damp f) (lambda (x) (average x (f x)))) 抽象和第一级过程（first-class procedures）程序设计语言会对计算元素可能使用方式加限制，带有最少限制的元素被称为具有第一级状态。第一级元素的某些权力或者特权包括： 可以用变量命名 可以提供给过程作为参数 可以由过程作为结果返回 可以包含在数据结构中 lisp给了过程完全第一级状态。 ch2 使用数据构建抽象概述我们只有简单的数值数据，许多问题不够处理。因此要构造一些对象（复合数据（compound data），程序设计语言需要提供胶水（glue）以构造），以模拟复杂现象。复合数据能提高程序的模块性，提高程序设计语言的表达能力。 介绍数据抽象数据抽象将数据的使用和实现分离。使用时主要用到选择函数（selectors）和构造函数（constructors），不需要了解实现细节。 例子：有理数算术操作12345(define (make-rat n d) (cons n d))(define (numer x) (car x))(define (denom x) (cdr x)) 抽象屏障（abstraction barriers）水平线是一层抽象屏障(过程)，上面使用，下面实现。 抽象屏障 优点是使程序便于维护和修改。 数据是什么？数据可以是过程。。。 序对（pairs）的过程性表示 12345678910(define (cons x y) (define (dispatch m) (cond ((= m 0) x) ((= m 1) y) (else (error \"Argument not 0 or 1 -- CONS\" m)))) dispatch)(define (car z) (z 0))(define (cdr z) (z 1)) 说明过程可以作为对象。有关的程序设计风格被称为消息传递（message passing）。 Church数提到了lambda演算。。。 一个易懂的系列文章 层次性数据和闭包（closure）性质之前构造复合数据的胶水是序对。 序对的盒子和指针表示 1(cons 1 2) 盒子和指针表示 可以建立元素本身是序对的序对，这一性质叫做cons的闭包性质。 组合数据对象具有闭包性质是说，组合起来的数据本身可以通过同样的操作再次组合。 序列的表示数据对象的有序集被称为序列（sequence）。 通过cons嵌套形成的序列称为表（list）。 1234(cons 1 (cons 2 (cons 3 (cons 4 nil)))) 盒子和指针表示 表操作讲了有关序列的操作list-ref、length、append、map 的具体实现。 层次性结构序列的序列，也可以认为是树 1(cons (list 1 2) (list 3 4)) 盒子和指针表示 树 序列作为约定的界面一种强有力的设计原理。 序列操作对于2个过程的信号流图 信号流图 123456(define (sum-odd-squares tree) (accumulate + 0 (map square (filter odd? (enumerate-tree tree))))) 123456(define (even-fibs n) (accumulate cons nil (filter even? (map fib (enumerate-interval 0 n))))) 表示成序列操作能帮我们得到模块化的程序设计。 符号数据为了扩充语言的表述能力，引进任意符号作为数据的功能。 抽象数据的多重表示数据对象可能有多种表示方法。 比如复数，可以表示成直角坐标形式和极坐标形式。设计一个程序的人在数据表示的选择上不能达成一致。所以除了需要表示和使用的抽象屏障，还要隔离互不相同的设计选择的抽象屏障。需要方法以将模块组合成大型系统。 复数表示复数的加法减法使用直角坐标更方便，乘法除法使用极坐标更方便。所以123456789101112(define (add-complex z1 z2) (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2))))(define (sub-complex z1 z2) (make-from-real-imag (- (real-part z1) (real-part z2)) (- (imag-part z1) (imag-part z2))))(define (mul-complex z1 z2) (make-from-mag-ang (* (magnitude z1) (magnitude z2)) (+ (angle z1) (angle z2))))(define (div-complex z1 z2) (make-from-mag-ang (/ (magnitude z1) (magnitude z2)) (- (angle z1) (angle z2)))) 但是复数的实现有2种1234567891011121314151617181920212223;;直角坐标(define (real-part z) (car z))(define (imag-part z) (cdr z))(define (magnitude z) (sqrt (+ (square (real-part z)) (square (imag-part z)))))(define (angle z) (atan (imag-part z) (real-part z)))(define (make-from-real-imag x y) (cons x y))(define (make-from-mag-ang r a) (cons (* r (cos a)) (* r (sin a))));;极坐标(define (real-part z) (* (magnitude z) (cos (angle z))))(define (imag-part z) (* (magnitude z) (sin (angle z))))(define (magnitude z) (car z))(define (angle z) (cdr z))(define (make-from-real-imag x y) (cons (sqrt (+ (square x) (square y))) (atan y x)))(define (make-from-mag-ang r a) (cons r a)) 带标志数据最小允诺原则（principle of least commitment）:由选择函数和构造函数形成的抽象屏障，把选择数据的具体表示形式的事情向后延迟。在同一个系统中若要有多种表示方式，需要使用类型标志以区分。 12345678910(define (attach-tag type-tag contents) (cons type-tag contents))(define (type-tag datum) (if (pair? datum) (car datum) (error \"Bad tagged datum -- TYPE-TAG\" datum)))(define (contents datum) (if (pair? datum) (cdr datum) (error \"Bad tagged datum -- CONTENTS\" datum))) 以此区分↓1234(define (rectangular? z) (eq? (type-tag z) 'rectangular))(define (polar? z) (eq? (type-tag z) 'polar)) 1234567891011121314151617181920212223242526272829;;直角坐标表示的修改版(define (real-part-rectangular z) (car z))(define (imag-part-rectangular z) (cdr z))(define (magnitude-rectangular z) (sqrt (+ (square (real-part-rectangular z)) (square (imag-part-rectangular z)))))(define (angle-rectangular z) (atan (imag-part-rectangular z) (real-part-rectangular z)))(define (make-from-real-imag-rectangular x y) (attach-tag 'rectangular (cons x y)))(define (make-from-mag-ang-rectangular r a) (attach-tag 'rectangular (cons (* r (cos a)) (* r (sin a)))));;极坐标表示的修改版(define (real-part-polar z) (* (magnitude-polar z) (cos (angle-polar z))))(define (imag-part-polar z) (* (magnitude-polar z) (sin (angle-polar z))))(define (magnitude-polar z) (car z))(define (angle-polar z) (cdr z))(define (make-from-real-imag-polar x y) (attach-tag 'polar (cons (sqrt (+ (square x) (square y))) (atan y x))))(define (make-from-mag-ang-polar r a) (attach-tag 'polar (cons r a))) 通用型选择函数实现这样的过程，检查参数的标志，然后调用相应过程123456789101112131415161718192021222324(define (real-part z) (cond ((rectangular? z) (real-part-rectangular (contents z))) ((polar? z) (real-part-polar (contents z))) (else (error \"Unknown type -- REAL-PART\" z))))(define (imag-part z) (cond ((rectangular? z) (imag-part-rectangular (contents z))) ((polar? z) (imag-part-polar (contents z))) (else (error \"Unknown type -- IMAG-PART\" z))))(define (magnitude z) (cond ((rectangular? z) (magnitude-rectangular (contents z))) ((polar? z) (magnitude-polar (contents z))) (else (error \"Unknown type -- MAGNITUDE\" z))))(define (angle z) (cond ((rectangular? z) (angle-rectangular (contents z))) ((polar? z) (angle-polar (contents z))) (else (error \"Unknown type -- ANGLE\" z)))) 构造函数1234(define (make-from-real-imag x y) (make-from-real-imag-rectangular x y))(define (make-from-mag-ang r a) (make-from-mag-ang-polar r a)) 于是运算的过程不需要做修改 通用复数运算系统结构 数据导向（data-directed）程序设计和可加性检查数据项的类型以此调用某个适当过程叫做基于类型的分派。优点是有模块性。缺点，一是通用型界面过程必须知道所有不同的表示，增加一个类型时必须对所有通用型界面过程增加子句以检查新类型，二是独立设计时需要保证加到系统时不会出现名字相同的过程。 以上通用型界面技术不具有可加性。大型系统需要解决这个问题。 一种称为数据导向的程序设计编程技术解决了这个问题。 需要一个表格 表格 需要2个对操作-类型表进行操作的过程12345;;安装(put &lt;op&gt; &lt;type&gt; &lt;item&gt;);;查找获取(get &lt;op&gt; &lt;type&gt;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748;;直角坐标表示(define (install-rectangular-package) ;; internal procedures (define (real-part z) (car z)) (define (imag-part z) (cdr z)) (define (make-from-real-imag x y) (cons x y)) (define (magnitude z) (sqrt (+ (square (real-part z)) (square (imag-part z))))) (define (angle z) (atan (imag-part z) (real-part z))) (define (make-from-mag-ang r a) (cons (* r (cos a)) (* r (sin a)))) ;; interface to the rest of the system (define (tag x) (attach-tag 'rectangular x)) (put 'real-part '(rectangular) real-part) (put 'imag-part '(rectangular) imag-part) (put 'magnitude '(rectangular) magnitude) (put 'angle '(rectangular) angle) (put 'make-from-real-imag 'rectangular (lambda (x y) (tag (make-from-real-imag x y)))) (put 'make-from-mag-ang 'rectangular (lambda (r a) (tag (make-from-mag-ang r a)))) 'done);;极坐标同理(define (install-polar-package) ;; internal procedures (define (magnitude z) (car z)) (define (angle z) (cdr z)) (define (make-from-mag-ang r a) (cons r a)) (define (real-part z) (* (magnitude z) (cos (angle z)))) (define (imag-part z) (* (magnitude z) (sin (angle z)))) (define (make-from-real-imag x y) (cons (sqrt (+ (square x) (square y))) (atan y x))) ;; interface to the rest of the system (define (tag x) (attach-tag 'polar x)) (put 'real-part '(polar) real-part) (put 'imag-part '(polar) imag-part) (put 'magnitude '(polar) magnitude) (put 'angle '(polar) angle) (put 'make-from-real-imag 'polar (lambda (x y) (tag (make-from-real-imag x y)))) (put 'make-from-mag-ang 'polar (lambda (r a) (tag (make-from-mag-ang r a)))) 'done) 通过这个过程访问表12345678(define (apply-generic op . args) (let ((type-tags (map type-tag args))) (let ((proc (get op type-tags))) (if proc (apply proc (map contents args)) (error \"No method for these types -- APPLY-GENERIC\" (list op type-tags)))))) 定义通用型选择函数1234(define (real-part z) (apply-generic 'real-part z))(define (imag-part z) (apply-generic 'imag-part z))(define (magnitude z) (apply-generic 'magnitude z))(define (angle z) (apply-generic 'angle z)) 定义构造函数1234(define (make-from-real-imag x y) ((get 'make-from-real-imag 'rectangular) x y))(define (make-from-mag-ang r a) ((get 'make-from-mag-ang 'polar) r a)) 消息传递（message passing）将表按列分解，不采用智能操作，而是采用智能数据对象。数据对象作为一个过程，以操作的名字作为参数，执行指定操作。 例子12345678910(define (make-from-real-imag x y) (define (dispatch op) (cond ((eq? op 'real-part) x) ((eq? op 'imag-part) y) ((eq? op 'magnitude) (sqrt (+ (square x) (square y)))) ((eq? op 'angle) (atan y x)) (else (error \"Unknown op -- MAKE-FROM-REAL-IMAG\" op)))) dispatch) 这个改成这个1(define (apply-generic op arg) (arg op)) 带有通用型操作的系统使用数据导向构造一个算数运算包，系统具有可加性。 算术运算包 通用算术过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105(define (add x y) (apply-generic 'add x y))(define (sub x y) (apply-generic 'sub x y))(define (mul x y) (apply-generic 'mul x y))(define (div x y) (apply-generic 'div x y));;scheme数字(define (install-scheme-number-package) (define (tag x) (attach-tag 'scheme-number x)) (put 'add '(scheme-number scheme-number) (lambda (x y) (tag (+ x y)))) (put 'sub '(scheme-number scheme-number) (lambda (x y) (tag (- x y)))) (put 'mul '(scheme-number scheme-number) (lambda (x y) (tag (* x y)))) (put 'div '(scheme-number scheme-number) (lambda (x y) (tag (/ x y)))) (put 'make 'scheme-number (lambda (x) (tag x))) 'done);;构造函数(define (make-scheme-number n) ((get 'make 'scheme-number) n));;有理数(define (install-rational-package) ;; internal procedures (define (numer x) (car x)) (define (denom x) (cdr x)) (define (make-rat n d) (let ((g (gcd n d))) (cons (/ n g) (/ d g)))) (define (add-rat x y) (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y)))) (define (sub-rat x y) (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y)))) (define (mul-rat x y) (make-rat (* (numer x) (numer y)) (* (denom x) (denom y)))) (define (div-rat x y) (make-rat (* (numer x) (denom y)) (* (denom x) (numer y)))) ;; interface to rest of the system (define (tag x) (attach-tag 'rational x)) (put 'add '(rational rational) (lambda (x y) (tag (add-rat x y)))) (put 'sub '(rational rational) (lambda (x y) (tag (sub-rat x y)))) (put 'mul '(rational rational) (lambda (x y) (tag (mul-rat x y)))) (put 'div '(rational rational) (lambda (x y) (tag (div-rat x y)))) (put 'make 'rational (lambda (n d) (tag (make-rat n d)))) 'done)(define (make-rational n d) ((get 'make 'rational) n d));;复数(define (install-complex-package) ;; imported procedures from rectangular and polar packages (define (make-from-real-imag x y) ((get 'make-from-real-imag 'rectangular) x y)) (define (make-from-mag-ang r a) ((get 'make-from-mag-ang 'polar) r a)) ;; internal procedures (define (add-complex z1 z2) (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2)))) (define (sub-complex z1 z2) (make-from-real-imag (- (real-part z1) (real-part z2)) (- (imag-part z1) (imag-part z2)))) (define (mul-complex z1 z2) (make-from-mag-ang (* (magnitude z1) (magnitude z2)) (+ (angle z1) (angle z2)))) (define (div-complex z1 z2) (make-from-mag-ang (/ (magnitude z1) (magnitude z2)) (- (angle z1) (angle z2)))) ;; interface to rest of the system (define (tag z) (attach-tag 'complex z)) (put 'add '(complex complex) (lambda (z1 z2) (tag (add-complex z1 z2)))) (put 'sub '(complex complex) (lambda (z1 z2) (tag (sub-complex z1 z2)))) (put 'mul '(complex complex) (lambda (z1 z2) (tag (mul-complex z1 z2)))) (put 'div '(complex complex) (lambda (z1 z2) (tag (div-complex z1 z2)))) (put 'make-from-real-imag 'complex (lambda (x y) (tag (make-from-real-imag x y)))) (put 'make-from-mag-ang 'complex (lambda (r a) (tag (make-from-mag-ang r a)))) 'done);;构造函数(define (make-complex-from-real-imag x y) ((get 'make-from-real-imag 'complex) x y))(define (make-complex-from-mag-ang r a) ((get 'make-from-mag-ang 'complex) r a)) 不同类型数据组合以上没有定义不同类型数据之间的运算。 一种方便的解决方案是强制(coercion)。 定义强制过程12(define (scheme-number-&gt;complex n) (make-complex-from-real-imag (contents n) 0)) 安装到强制表1(put-coercion 'scheme-number 'complex scheme-number-&gt;complex) 修改这个过程123456789101112131415161718192021(define (apply-generic op . args) (let ((type-tags (map type-tag args))) (let ((proc (get op type-tags))) (if proc (apply proc (map contents args)) (if (= (length args) 2) (let ((type1 (car type-tags)) (type2 (cadr type-tags)) (a1 (car args)) (a2 (cadr args))) (let ((t1-&gt;t2 (get-coercion type1 type2)) (t2-&gt;t1 (get-coercion type2 type1))) (cond (t1-&gt;t2 (apply-generic op (t1-&gt;t2 a1) a2)) (t2-&gt;t1 (apply-generic op a1 (t2-&gt;t1 a2))) (else (error \"No method for these types\" (list op type-tags)))))) (error \"No method for these types\" (list op type-tags))))))) 类型的层次结构在实际中，还存在着不同类型相互关系更全局性的结构。 塔结构 这被称为塔结构。优点是简化了新类型的加入，加入时只需要知道如何连接上面的超类型，以及如何作为下面的超类型，强制转化时只需逐层上升。并且实现了继承的概念，能够继承超类型的所有操作。另一个优点是，下降它可以使它到达最简单的表达形式。 层次结构的不足遗憾的是，事情通常不是这样。一个类型有可能有多个子类型，也有可能有多个超类型。这是当时在研究的领域。 图形的关系 ch3 模块化，对象和状态概述前面讲了将过程和数据组合起来构造复合实体，在克服大型系统复杂性问题，抽象有重要作用。但是对于设计程序而言，这些手段不够用，还需要组织原则，系统化完成系统的整体设计。 基于被模拟系统的结构去设计程序的结构，是一种强有力的设计策略。且希望扩充时不必做全面修改。 以下研究2种特点鲜明的设计策略，源自于对系统结构的2种世界观。第一种关注对象，可能随时间变化。另一种关注流过系统的信息流，像信号处理系统。 赋值（assignment）和局部状态对象具有随时间变化的状态，对象可能通过交互影响其它对象的状态。因为状态会改变，语言必须提供一个赋值运算符。 例子123456789101112131415(define (make-account balance) (define (withdraw amount) (if (&gt;= balance amount) (begin (set! balance (- balance amount)) balance) \"Insufficient funds\")) (define (deposit amount) (set! balance (+ balance amount)) balance) (define (dispatch m) (cond ((eq? m 'withdraw) withdraw) ((eq? m 'deposit) deposit) (else (error \"Unknown request -- MAKE-ACCOUNT\" m)))) dispatch) 引进赋值带来的利益不用赋值： x2 = (rand-update x1) x3 = (rand-update x2) 使用赋值：12345(define rand (let ((x random-init)) (lambda () (set! x (rand-update x)) x))) 与所有状态都必须显式地操作和传递额外参数的方式相比，通过引入赋值和将状态隐藏在局部变量中的技术，我们能以一种更模块化的方式构造系统。 引进赋值的代价一旦在语言里引进了赋值，代换就不再适合作为过程应用的模型了。 不使用赋值的程序设计叫函数式编程（functional programming）。使用赋值的程序设计叫命令式编程（imperative programming）。 引入赋值，一个变量不是一个简单的名字，而是索引一个保存值的位置，位置上的值可变。 同一和变化如果一个语言在表达式里支持“同一的东西可以相互替换”的概念，这样替换不会改变表达式的值，这个语言就称为是具有引用透明性（referentially transparent）。 在我们的计算机语言包含了赋值操作之后，也就打破了引用透明性。 命令式程序设计的缺陷命令式编程中赋值可能要有相对顺序才是正确的(若有多个并发执行的程序，复杂性会糟糕)，函数式编程不需要考虑顺序。 求值的环境模型（environment model）引入赋值，一个变量不是一个简单的名字，而是索引一个保存值的位置。在新的求值模型中，位置维持在称为环境的结构中。 环境是框架的一个序列（frame）。框架是包含约束的表格，约束将一些变量名字关联于对应的值。每个框架有一个指针，指向框架的外围环境。如果框架是全局的，它将没有外围环境。一个变量相对于某个特定环境的值，是在这一环境中，包含着该变量的第一个框架里的约束值。若不存在，则说这个变量在该特定环境无约束。 如图，A、B、C、D是环境，Ⅰ、Ⅱ、Ⅲ是框架，框架中是约束。 环境模型 求值规则关于解释器如何求值一个组合式的问题，其整体描述仍然与第一次介绍时完全一样。如果要对一个组合表达式求值： 求值这一组合式里的各个子表达式。 将运算符子表达式的值应用于运算对象子表达式的值。 现在我们要用求值的环境模型代替求值的代换模型。 创建过程一个过程是一些代码和一个指针的序对。 例如 12(define (square x) (* x x)) 环境模型 应用过程在将一个过程应用于一组实际参数时，将会建立起一个新环境，其中包含了将所有形式参数约束于对应的实际参数的框架，该框架的外围环境就是所用的那个过程的环境。随后就在这个新环境之下求值过程体。 1(square 5) 环境模型 简单过程的应用使用环境模型分析实例 123456(define (square x) (* x x))(define (sum-of-squares x y) (+ (square x) (square y)))(define (f a) (sum-of-squares (+ a 1) (* a 2))) 环境模型 1(f 5) 环境模型 将框架看作局部状态的仓库一个例子 12345678(define (make-withdraw balance) (lambda (amount) (if (&gt;= balance amount) (begin (set! balance (- balance amount)) balance) \"Insufficient funds\")))(define W1 (make-withdraw 100)) 环境模型 1(W1 50) 环境模型 环境模型 1(define W2 (make-withdraw 100)) 环境模型 内部定义利用环境模型考察内部定义的行为 123456789101112(define (sqrt x) (define (good-enough? guess) (&lt; (abs (- (square guess) x)) 0.001)) (define (improve guess) (average guess (/ x guess))) (define (sqrt-iter guess) (if (good-enough? guess) guess (sqrt-iter (improve guess)))) (sqrt-iter 1.0)) (sqrt 2) 环境模型 用变动数据（mutable data）做模拟为了模拟那些由具有不断变化的状态组成的系统，我们除了需要做复合数据对象的构造和成分选择之外，还可能需要修改它们。为了模拟具有不断变化的状态的复合对象，我们将设计出与之对应的数据抽象，使其中不但包含了选择函数和构造函数，还有包含一些称为改变函数的操作，这种操作能够修改有关的数据对象。 举例，对银行系统的模拟就需要修改账户的余额。1（set-balance！&lt;accoun&gt; &lt;new-value&gt;） 下面都是例子。。。 在此不列出 并发（concurrency）：时间是一个本质问题具有内部状态的计算对象，存在时间问题，同一个表达式求值，却产生不同结果，因为赋值语句执行依赖于求值发生的时间。 现实中的对象是并发活动的，顺序计算机可以把它们像并发一样执行，可以使程序更加模块化，提供速度优势。 赋值使问题严重。 在处理时间和状态时，我们在计算模型领域所遭遇的复杂性，事实上，可能就是物理世界中最基本的复杂性。 并发系统中时间的性质从表面上看，时间似乎是非常简单的东西。它也就是强加在各种事件上的一个顺序。 时间顺序的非确定性，可能对并发系统的设计提出严重问题。 一个例子 时间顺序的问题 使事情变得更加复杂的原因，就是多个进程有可能同时试图去操作共享的状态。 并发程序的正确行为上面例子的情况非常典型，是可能潜藏在并发程序里的微妙错误。这一复杂性的根源，就在于这里出现了对不同进程之间共享的变量的赋值。对于并发进程，我们对于赋值就更需要特别小心，因为在这里可能无法控制其他进程所做赋值的出现顺序。如果几个这样的修改可能并发出现，我们就需要采用某些方式，以设法保证系统的行为是正确的。 对于并发的一种可能限制方式是规定，修改任意共享状态变量的两个操作都不允许同时发生。这是一个特别严厉的要求。这样做可能过于低效，也太保守了。 对于并发的另一种不那么严厉的限制方式是，保证并发系统产生出的结果与各个进程按照某种方式顺序运行产生出的结果完全一样。事件数量增加时，就很复杂。 控制并发的机制另一种更实际的方法是，在设计并发系统时，设法做出一些一般性的机制，使我们可能限制并行进程之间的交错情况，以保证程序具有正确的行为方式。人们已经为此目的而开发了许多不同的机制。这一节里将讨论其中的一种：串行化组（serializer）。 对共享变量的串行访问串行化就是实现下面的想法：使进程可以并发地执行，但是其中也有一些过程不能并发地执行。说得更准确些，串行化就是创建一些不同的过程集合，并且保证在每个时刻，在任何一个串行化集合里至多只有一个过程的一个执行。如果某个集合里有过程正在执行，而另一进程企图执行这个集合里的任何过程时，它就必须等待到前一过程的执行结束。我们可以借助串行化去控制对共享变量的访问。 例子 假设有一个实现串行执行的过程1(parallel-execute &lt;p1&gt; &lt;p2&gt; ... &lt;pk&gt;) 使用make-serializer构造串行化组，串行化组以过程为参数，返回串行化的过程。对一个给定串行化组的所有调用返回的串行化过程都属于同一个集合。以实现执行过程不会交错进行。 例如123456(define x 10)(define s (make-serializer))(parallel-execute (s (lambda () (set! x (* x x)))) (s (lambda () (set! x (+ x 1))))) 下面是存款和取款操作已经做了串行化的make-account1234567891011121314151617(define (make-account balance) (define (withdraw amount) (if (&gt;= balance amount) (begin (set! balance (- balance amount)) balance) \"Insufficient funds\")) (define (deposit amount) (set! balance (+ balance amount)) balance) (let ((protected (make-serializer))) (define (dispatch m) (cond ((eq? m 'withdraw) (protected withdraw)) ((eq? m 'deposit) (protected deposit)) ((eq? m 'balance) balance) (else (error \"Unknown request -- MAKE-ACCOUNT\" m)))) dispatch)) 使用多重共享资源的复杂性串行化提供了一种非常强有力的抽象，能帮助我们将并发程序的复杂性孤立起来，使这种程序能够被小心地和（希望是）正确地处理。然而，如果只存在一个共享资源（例如一个银行账户），串行化的使用问题是相对比较简单的。但是如果存在着多项共享资源，并发程序设计就可能变得非常难以把握了。 串行化的实现我们将用一种更基本的称为互斥元（mutex）的同步机制来实现串行化。互斥元是一种对象，假定它提供了两个操作。一个互斥元可以被获取（acquired）或者被释放（released）。一旦某个互斥元被获取，对于这一互斥元的任何其他获取操作都必须等到该互斥元被释放之后。 在我们的实现里，每个串行化组关联着一个互斥元。给了一个过程p，串行化组将返回一个过程，该过程将获取相应互斥元，而后运行p，而后释放该互斥元。这样就能保证，由这个串行化组产生的所有过程中，一次只能运行一个，这就是需要保证的串行化性质。 死锁（deadlock）现在已经看了可以如何实现串行化，但也应该看到，即使采用了上面给出的过程serialized-exchange，在账户交换问题里还存在一个麻烦。 现在设想Peter企图去交换账户al和a2，同时Paul并发地企图去交换a2和a1。假定Peter的进程到达这样一点，此时它已经进入了保护a1的串行化进程，而正好在此之后，Paul的进程也进入了保护a2的串行化进程。现在Peter已经无法继续前进了（因为无法进入保护a2的串行化进程），他需要一直等到Paul退出保护a2的串行化进程。与Peter的情况类似，Paul也无法前进了，他需要等到Peter退出保护a1的串行化进程。这样每个进程都要无穷无尽地等待下去，等着另一个进程的活动，这种情况就称为死锁。在那些提供了对于多种共享资源的并发访问的系统里，总是存在着死锁的危险。 流（streams）如果用离散的步长去度量时间，那么我们就可以用一个（可能无穷的）序列去模拟一个时间函数。在这一节里，我们将看到如何用这样的序列去模拟变化，为了做到这些，我们需要引进一种称为流的新数据结构，探索对状态进行模拟的另一条途径，以避免赋值带来的问题。 流作为延时的表流是一种非常巧妙的想法，使我们可能利用各种序列操作，但又不会带来将序列作为表去操作而引起的代价。利用流结构，我们能得到这两个世界里最好的东西：如此形成的程序可以像序列操作那么优雅，同时又能得到递增计算的效率。如果使用者需要访问这个流的尚未构造出的那个部分，那么这个流就会自动地继续构造下去，但是只做出足够满足当时需要的那一部分。 例如通过序列方式去计算从10000到1000000的区间里的第二个素数，这种低效情况就表现得太明显了： 12(car (cdr (filter prime? (enumerate-interval 10000 1000000)))) 而使用流计算从10000到1000000的区间里的第二个素数1234(stream-car (stream-cdr (stream-filter prime? (stream-enumerate-interval 10000 1000000)))) 最终到这一步就返回了1000912345678(cons 10009 (delay (stream-filter prime? (cons 10010 (delay (stream-enumerate-interval 10011 1000000)))))) delay和force的实现delay必须包装起一个表达式，使它可以在以后根据需要去求值1（delay &lt;exp&gt;） 实际上不过是在下面形式的外面包装起一层语法糖衣：1（lambda（）&lt;exp&gt;） 而force也就是简单地调用由delay产生的那种（无参）过程12（define（force delayed-object）（delayed-object）） 无穷流例如 正整数1234(define (integers-starting-from n) (cons-stream n (integers-starting-from (+ n 1))))(define integers (integers-starting-from 1)) 隐式地定义流例如 1,1,1,…1(define ones (cons-stream 1 ones)) 例如 Fibonacci 数12345(define fibs (cons-stream 0 (cons-stream 1 (add-streams (stream-cdr fibs) fibs)))) 流计算模式的使用系统地将迭代操作方式表示为流过程例如1234567891011121314151617(define (sqrt-improve guess x) (average guess (/ x guess)))(define (sqrt-stream x) (define guesses (cons-stream 1.0 (stream-map (lambda (guess) (sqrt-improve guess x)) guesses))) guesses)(display-stream (sqrt-stream 2))1.1.51.41666666666666651.41421568627450971.4142135623746899... 序对的无穷流 序对的无穷流 12345678910111213141516(stream-map (lambda (x) (list (stream-car s) x)) (stream-cdr t))(define (interleave s1 s2) (if (stream-null? s1) s2 (cons-stream (stream-car s1) (interleave s2 (stream-cdr s1)))))(define (pairs s t) (cons-stream (list (stream-car s) (stream-car t)) (interleave (stream-map (lambda (x) (list (stream-car s) x)) (stream-cdr t)) (pairs (stream-cdr s) (stream-cdr t))))) 将流作为信号实现一个积分器 S_i=C+\\sum_{j=1}^{i}x_jdt123456(define (integral integrand initial-value dt) (define int (cons-stream initial-value (add-streams (scale-stream integrand dt) int))) int) 信号处理系统 流和延迟求值定义反馈循环的能力依赖于 delay。 规范序求值我们已经构造出了两类过程：常规的过程和要求延时参数的过程。一般说，如果创建了不同种类的过程，就将迫使我们同时去创建不同种类的高阶过程。为了避免这个问题，一种方式是让所有过程都用延时参数。我们可以采纳一种求值模型，其中所有过程参数都自动延时，只有在实际需要它们的时候才强迫参数求值。这样做，就把我们的语言转到了采用规范序的方式。 不幸的是，把延时包含到过程调用中，将会对我们设计依赖于事件顺序的程序的能力造成极大损害。 目前所有的人都知道，变动性和延时求值在程序设计语言里结合得非常不好，设计出某些方式，适当地处理这两种东西，仍然是一个很活跃的研究领域。 函数式程序的模块化和对象的模块化引进赋值的主要收益就是使我们可以增强系统的模块化，把一个大系统的状态中的某些部分封装隐藏到局部变量里。流模型可以提供等价的模块化，同时又不必使用赋值。 时间的函数式程序设计观点本章开始时提出了一个目标，那就是构造出一些计算模型，使其结构能够符合我们对于试图去模拟的真实世界的看法。我们可以将这一世界模拟为一集相互分离的、受时间约束的、具有状态的相互交流的对象，或者可以将它模拟为单一的、无时间也无状态的统一体。每种观点都有其强有力的优势，但就其自身而言，又没有一种方式能够完全令人满意。我们还在等待着一个大统一的出现。 总结主要通过实例和习题来理解。。。 然而毕竟是入门课程，其中涉及的很多知识点在其它地方都了解过了。。。","categories":[{"name":"课程","slug":"课程","permalink":"https://4eay7lab.com/categories/课程/"}],"tags":[{"name":"本科补全","slug":"本科补全","permalink":"https://4eay7lab.com/tags/本科补全/"},{"name":"程序设计","slug":"程序设计","permalink":"https://4eay7lab.com/tags/程序设计/"},{"name":"sicp","slug":"sicp","permalink":"https://4eay7lab.com/tags/sicp/"}]},{"title":"nand2tetris ch6 汇编器","slug":"nand2tetris-6","date":"2019-07-10T16:00:00.000Z","updated":"2020-10-26T07:31:31.407Z","comments":true,"path":"2019/07/11/nand2tetris-6/","link":"","permalink":"https://4eay7lab.com/2019/07/11/nand2tetris-6/","excerpt":"","text":"这一章没多少新内容，主要是按照规则写个汇编器。。。 概述从第6章开始将开始关注计算机的软件层次，其中，汇编器是最基础的模块。 符号汇编指令和相应的二进制编码之间的关系很直接，所以写一个汇编器不难。唯一的困难是管理用户定义符号并解析到物理内存地址，通常会使用符号表（数据结构是哈希表）来完成，这在许多软件翻译项目中都有用到。 由于二进制码的含义相当晦涩，通常机器语言会指定它的二进制码（Binary codes）和符号助记符（Symbolic mnemonics）。我们不仅可以借助符号读程序，也可以这样写程序而不必使用二进制。我们可以使用一个文本处理程序，将符号解析为二进制机器指令。这个符号就叫做汇编语言（Assembly），这个程序叫做汇编器（Assembler），这个过程叫做汇编。 符号汇编语言中会出现符号，符号指代内存中的地址。 变量程序员用到的符号变量名，翻译器会自动分配到内存地址。 标签程序员用标签标记程序中的不同位置。 符号解析把有符号的程序转换成无符号的代码。 一个例子： 一个例子 汇编器我们看到汇编器本质上是一个提供翻译服务的文本处理程序。 汇编器需要遵守机器语言规范（machine language specification），执行以下任务（不一定是这个顺序）： 将符号指令解析为其基础字段。 对于每个字段，用机器语言生成相应的位。 用内存的数字地址替换所有符号引用（如果有）。 将二进制代码汇编成完整的机器指令。 除了替换符号为地址这一步，其它3步都比较简单。 Hack汇编翻译规范语法传统和文件格式二进制文件（Binary code files）扩展名为hack。一行一个16位01串，指定一个机器语言指令。第n行地址为n（n是从0开始的）。 汇编文件（Assembly language files）扩展名为asm。 每行为一个Instruction或者 (Symbol)。 常量非负且为10进制，用户定义的符号可以是字母、数字、下划线（_）、点（.）、美元符号（$）、冒号（:），不能以数字开头。 //后为单行注释。 空白、空行忽略。 约定助记符、标记名大写，变量名小写。 指令 A C comp dest jump 符号预定义符号（Predefined symbols）RAM的一部分地址可以用预定义符号指定。 虚拟寄存器（Virtual registers）：用R0~R15指定RAM[0]~RAM[15]。 预定义指针（Predefined pointers）：用SP、LCL、ARG、THIS、THAT指定RAM[0]~RAM[4]。 I/O指针（I/O pointers）：用SCREEN、KBD指定RAM[16384]（RAM[0x4000]）和RAM[24576]（RAM[0x6000]），这是屏幕和键盘的内存映射的基地址。 标记符号（Label symbols）用户定义的用于表示goto的目的地址的符号，用伪命令“(Xxx)”来声明。 变量符号（Variable symbols）用户定义的符号Xxx，Xxx不是预定义符号和标记符号，那么就是一个变量，汇编器会分配一个唯一的内存地址，从RAM[0x0010]开始。 API官方提供了可以参考的API。 Parser parser parser Code parser 无符号汇编器用以上2个模块即可。 SymbolTable就是一个哈希表。 parser 有符号汇编器用上符号表，按照以下步骤实现有符号汇编器： 初始化：把预定义符号添加到符号表。 第一遍：扫描一遍，把标记符号添加到符号表。 第二遍：扫描一遍，把变量符号（只会出现在A指令）添加到符号表，完成指令的翻译。 项目用任意编程语言开发一个汇编器，能将asm文件汇编为hack文件。要求和官方提供的汇编器的汇编功能一致。可能用到的工具依然是官方提供的汇编器。。。 （我的代码见github","categories":[{"name":"课程","slug":"课程","permalink":"https://4eay7lab.com/categories/课程/"}],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"https://4eay7lab.com/tags/计算机系统/"},{"name":"nand2tetris","slug":"nand2tetris","permalink":"https://4eay7lab.com/tags/nand2tetris/"},{"name":"本科补全","slug":"本科补全","permalink":"https://4eay7lab.com/tags/本科补全/"}]},{"title":"nand2tetris ch5 计算机体系结构","slug":"nand2tetris-5","date":"2019-07-08T16:00:00.000Z","updated":"2020-10-26T07:31:31.407Z","comments":true,"path":"2019/07/09/nand2tetris-5/","link":"","permalink":"https://4eay7lab.com/2019/07/09/nand2tetris-5/","excerpt":"","text":"概述这一章是硬件部分（1-5章）的最后一章。这一章会使用1-3章的芯片造一个通用计算机（名为Hack），并且可以运行第4章的机器语言编写的程序。 Hack有2个优点，一是简单，几个小时就可以用芯片和硬件模拟器造出来，二是它能够说明任何数字计算机的关键操作和硬件组成。 存储程序概念（The Stored Program Concept）数字计算机是多功能的，能够在有限的硬件平台加载不同的程序，执行多种的任务，从交互式游戏到文字处理再到科学计算，这是存储程序概念带来的结果。 冯诺依曼结构（The von Neumann Architecture）存储程序概念是抽象和实用的计算机模型的关键要素，最值得注意的是通用图灵机（universal Turing machine）（1936年）和冯诺依曼机（von Neumann machine）（1945年）。图灵机是一个抽象描述，用于分析计算机系统的逻辑基础。冯诺依曼机是一个实用的结构，它是现在几乎所有计算机的概念蓝图。 冯诺依曼结构基于一个CPU，和存储设备交互，从输入设备获取数据，发送数据到输出设备。中心是基于存储程序概念，存储器存储数据和指令。下面讲这种结构的细节。 冯诺依曼结构 存储器（Memory）冯诺依曼的存储器存储2种类型的信息：数据和指令。它们存储在不同的单元中，而它们都是以二进制形式表示，存储在基本的随机存取结构中：一个连续的固定字长的单元的数组（Words or Locations），每一个单元都有唯一的地址（Address）。通过提供地址来确定一个字。 数据存储器（Data Memory）高级程序的抽象部分，比如变量、数组、对象，以二进制形式存储在数据存储器。 指令存储器（Instruction Memory）高级程序命令被翻译成机器语言，以二进制形式储存在指令存储器。 CPU（Central Processing Unit）CPU作为计算机结构的中心，执行被加载的程序的指令。指令告诉CPU进行各种计算、读写数据、条件跳转。CPU使用3个主要的硬件来执行任务：ALU、寄存器、控制单元。 ALU（Arithmetic Logic Unit）进行低级的算术和逻辑运算。 控制单元（Control Unit）指令是二进制编码，在它执行之前需要解码，并且其中的信息必须给一些硬件设备信号，以执行指令。解码就是由控制单元完成的。 现在，CPU的操作可以被描述为一个循环：取指令，解码，执行，再取指令… 寄存器（Registers）和RAM相比，寄存器可以更快捷地存取数据。 寄存器有多种用处： 数据寄存器（Data registers）提供数据暂存功能。 寻址寄存器（Addressing registers）地址被存储在寄存器，以访问内存地址，存取数据。 程序计数器寄存器（Program counter register）执行程序时，CPU必须始终保持跟踪，获取下一条指令的地址。这个地址被保存在一个特殊的寄存器PC中，也就是PC中的内容将作为下一条指令的地址。在执行指令时，PC会用2种方法中的一种更新：没有goto指令，PC把地址+1；有goto n，PC修改为n。 输入和输出（Input and Output）外设有很多，每种都代表着一种独特的机械设备，需要独特的工程知识。于是，计算机科学家设计了各种方案，使所有这些设备看起来与计算机相同。 此领域中最简单的技术称为内存映射I/O（memory-mapped I/O）。基本思路是创建一个I/O设备的二进制模拟，使它对于CPU来说就像一个普通的内存段。 Hack硬件平台规范（The Hack Hardware Platform Specification）概观Hack是一个冯诺依曼结构的计算机，16位，组成部分有CPU、2个分立的存储模块（一个指令存储器、一个数据存储器）、2个内存映射I/O设备（一个屏幕、一个键盘）。 CPU执行指令存储器中的指令。指令存储器是一个只读的设备，程序是由一些外部方法写入的。 现在开始，我们认为Hack的数据存储器和指令存储器分别为RAM和ROM。 CPU由ALU、D寄存器、A寄存器、PC寄存器组成。 D、A是16位通用寄存器。D用来存数据。A用来存数据、或存放RAM地址、或存放ROM地址。 机器语言基于2种指令类型，A指令、C指令。 计算机的连接方式中，PC的输出被连接到ROM的地址输入。 一个时钟周期，计算机的操作为：取指令，执行。一个“取指令-执行”周期表明一个内存访问操作一般包括寻址指令和一个后续指令（读写指令、分支指令）。 CPU CPU ROM这是内建的，我们只要把程序加载进去。 ROM32K 屏幕内建的，不需要实现内部细节。 屏幕 键盘内建的，不需要实现内部细节。 键盘 特殊的键值： 键值 总内存（Overall Memory）包括RAM和屏幕、键盘的内存映射。 数据存储器 计算机（Computer）计算机芯片包含所有必要的硬件设备来操作计算机，包括CPU、数据存储器、指令存储器、屏幕、键盘。 计算机 这些当然还是在用HDL写，然后在硬件模拟器里模拟。 这里建造的难点是CPU，其他的都很直接了。 实现CPU的实现最难的是CPU。 CPU就是取指令、执行。。。 先了解A指令和C指令： A指令 C指令 了解后可得到以下数据通路： CPU的实现 其中控制逻辑（control logic）没有详细给出（图中的C）。 控制逻辑需要完成以下任务： 指令译码一条16位的指令可能是A指令或C指令。为了知道一条指令的含义，需要将一条指令分为‘i xx a cccccc ddd jjj’几个字段。 i：若为0就是A指令，若为1就是C指令。 a cccccc：C指令comp部分。 ddd：C指令dest部分。 jjj：C指令jump部分。 A指令除了i位的低15位被解释成一个常数。 指令执行将‘i xx a cccccc ddd jjj’这几个部分同时发送到相应的结构执行相应操作。 取下一条指令执行一条指令的同时需要知道下一条指令。 CPU使用PC的输出作为pc端的输出。 t是现在的时间单元，默认的操作是$PC(t)=PC(t-1)+1$。如果需要goto n，需要先通过A指令把A寄存器设置为n，然后再跳转。 所以我们需要实现以下逻辑： $PC(t)=\\begin{cases}A(t-1),&amp;jump(t) \\cr PC(t-1)+1,&amp;otherwise\\end{cases}$ 计算机的实现 计算机的实现 总结Hack是一种最小化的计算机。然而从定性的角度来看，Hack与大多数数字计算机非常相似，因为它们都遵循相同的概念：冯诺依曼架构。 在功能方面，计算机系统可分为两类：通用计算机，旨在轻松切换执行一个程序；专用计算机，通常嵌入其他系统，对于任何特定的应用程序，单个程序被烧录到专用计算机的ROM，是唯一可以执行的。（Hack应该是专用计算机。。。？） 除了这种差异，通用和专用计算机共享相同的架构思想：存储程序，获取-解码-执行的逻辑，CPU，寄存器，程序计数器等等。 大多数通用计算机使用单个地址空间来存储数据和指令，而Hack将其分成两个独立的部分。 在I / O方面，Hack键盘和屏幕相当简洁。 设计中的大部分努力都是为了使计算机硬件有更好的性能。 因此，硬件架构课程和教科书通常围绕诸如内存层次结构（缓存），对I / O设备的更好访问，流水线，并行性，指令预取以及其他优化技术展开，当然在这门课程中都没有涉及。 从历史上看，尝试提高处理器的性能已经导致了两个设计模式。 复杂指令集计算机（CISC）通过提供丰富的功能和复杂的指令来实现更好的性能。精简指令集计算机（RISC）使用更简单的指令集来促进硬件尽可能快速实施。 Hack计算机不属于以上2者（。。。）。 项目project是用之前造好的芯片来实现Hack电脑平台。（我的代码见github 使用硬件模拟器测试。 可能需要查看附录A和附录B。 需要建造的芯片列表： Memory CPU Computer","categories":[{"name":"课程","slug":"课程","permalink":"https://4eay7lab.com/categories/课程/"}],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"https://4eay7lab.com/tags/计算机系统/"},{"name":"nand2tetris","slug":"nand2tetris","permalink":"https://4eay7lab.com/tags/nand2tetris/"},{"name":"本科补全","slug":"本科补全","permalink":"https://4eay7lab.com/tags/本科补全/"}]},{"title":"nand2tetris ch4 机器语言","slug":"nand2tetris-4","date":"2019-07-06T16:00:04.000Z","updated":"2020-10-26T07:31:31.406Z","comments":true,"path":"2019/07/07/nand2tetris-4/","link":"","permalink":"https://4eay7lab.com/2019/07/07/nand2tetris-4/","excerpt":"","text":"概述机器语言处于软件和硬件之间，既是一个编程工具，也是硬件平台的组成部分。它旨在编写低级程序当作一系列的机器指令，这些指令命令处理器执行算术和逻辑运算、从内存中存取值、将一个寄存器的值移动到另一个寄存器、测试布尔条件等。和高级语言不同，机器语言的要求是直接执行和完全控制特定的硬件平台。 了解用机器语言编写的低级程序，可以方便我们熟悉计算机系统。这不仅帮助我们理解如何编程，而且可以知道硬件为何这样设计。 下面会先大致介绍机器语言，然后给出Hack的机器语言的具体细节，包括二进制版本（Binary）以及符号汇编版本（Symbolic assembly）。注意，我们在这里抽象底层硬件的具体实现，只需要关注一个处理器（Processor）、一个内存（Memory）、一些寄存器（Registers）。 机器（Machines）内存（Memory）这里指存储数据和指令的设备。一个连续的固定字宽的单元的数组（Words or Locations），每一个单元都有唯一的地址（Address）。 下面我们将内存中的某个字简称为Memory[address]，RAM[address]，或者 M[address]。 处理器（Processor）也叫做中央处理单元（Central Processing Unit or CPU），指能够执行一些固定的基本操作的设备，包括算术和逻辑操作，内存访问操作，控制（也被称作分支，Branching）操作。操作数（Operands）是来自寄存器或内存的二进制值，同样，操作结果也存放在寄存器或者内存中。 寄存器（Register）内存访问是一个相对较慢的操作，需要长指令格式（比如可能需要32位的地址）。于是，大多数处理器都配备有寄存器，每个寄存器能存一个值。寄存器相当于一个位于处理器的高速本地内存，可以快速操纵数据和指令。它使程序减少内存访问，以提高程序执行效率。 语言（Languages）机器语言是一系列的被编码的指令，它的含义取决于硬件细节和机器语言语法。 由于二进制码的含义相当晦涩，通常机器语言会指定它的二进制码（Binary codes）和符号助记符（Symbolic mnemonics）。 比如，假设有某种add操作，可以直接写成1010001100011001，或者用符号写成ADD R3,R1,R9。 我们不仅可以借助符号读程序，也可以这样写程序而不必使用二进制。我们可以使用一个文本处理程序，将符号解析为二进制机器指令。这个符号就叫做汇编语言（Assembly language, or simply assembly），这个程序叫做汇编器（Assembler），这个过程叫做汇编。 不同的计算机的CPU的操作、寄存器的种类和数量、汇编语言的语法都有可能不同（a Tower of Babel of machine languages）。 尽管不同，它们却都有一些相似的通用的命令。 指令（Commands）算术和逻辑运算（Arithmetic and Logic Operations）每一个计算机都要进行基本的算术和逻辑运算。 算术和逻辑运算 内存访问（Memory Access）内存访问指令有2类，一是算术和逻辑运算命令，可能不仅操纵寄存器，还有内存，二是存取（load and store）命令，会在寄存器和内存之间移动数据。内存访问命令有不同的寻址方式（Addressing modes），也就是获取内存的字的具体的方法。通常，不同的计算机提供不同的可能方式和表达，但是以下3种一般都会支持。 直接寻址（Direct addressing）直接给出具体地址或者用符号表示一个具体的地址。 直接寻址 立即数寻址（Immediate addressing）加载常数（出现在指令编码中的值）到寄存器。不是这个常数所对应的地址上的值，而是这个常数本身。 立即数寻址 间接寻址（Indirect addressing）地址没有被硬编码到指令中，而是指定了一个保存所需地址的内存位置。这种方式被用于处理指针（Pointers）。 比如，高级指令x=foo[j]，foo是一个数组变量，x、j是整型变量。在声明和初始化foo后，编译器分配一个内存段来保存数组数据，使foo指代一个段的基地址（Base address）。foo[j]就是在foo上偏移了一个j的地址上的值。 间接寻址 控制流（Flow of Control）当一个程序线性地执行命令时，可能会出现分支跳转到一个地址，而不是继续执行下一个命令。 分支的目的有很多，比如循环（Repetition），条件执行（Conditional execution），子程序调用（Subroutine calling）。跳转的位置可以是一个给定的标记（Label）。 跳转有无条件跳转（Unconditional jump）和有条件跳转（Conditional jump，可以有明确的布尔条件或者是上一个命令的作用）。 以上为机器语言的介绍，接下来是Hack的机器语言的描述。 Hack的机器语言注意：Hack的机器语言是一种很简单的机器语言，现在大多数计算机都有比Hack更复杂的指令、数据类型、寄存器、指令格式、寻址方式（当然Hack可以用软件来实现它们）。 概观Hack是一个冯诺依曼结构的计算机，16位，组成部分有CPU、2个分立的存储模块（一个指令存储器、一个数据存储器）、2个内存映射I/O设备（一个屏幕、一个键盘）。 内存地址空间Hack程序员关注2个地址空间：指令存储器和数据存储器。2个存储器都是16位字长，15位的地址空间，即每个存储器存储容量是32K（即$2^{15}$）$\\times$16 bit。 CPU只执行指令存储器中的指令。这里的指令存储器是一个只读的设备，程序是由一些外部方法写入的。比如，一个预先烧录好的ROM芯片可以实现指令存储器。如果要一个新的程序需要换一个ROM。 寄存器关注2个16位的寄存器，D寄存器和A寄存器，它们可以被算术和逻辑指令操纵。D寄存器用来存数据，A寄存器当作数据以及地址（指令存储器或数据存储器的地址）的寄存器。 A寄存器可以加快直接访问存储器。Hack的指令是16位的，地址是15位的，所以不可能把操作和地址放在一条指令中。于是Hack的内存访问指令会操纵一个隐式的地址，标记为M。 比如，对于数据存储器，要实现的是D=Memory[516]-1，我们就先用一条指令设置A寄存器为516，再用一条D=M-1指令。 比如，对于指令存储器，要实现的是goto 35，先用一条指令设置A寄存器为35，再使用goto指令，计算机会在下一个时钟周期取InstructionMemory[35]的指令。 指令Hack的2种基础指令： 地址指令 A指令 计算指令 C指令 A指令设置A寄存器为一个15位的值。 A指令 A指令的3种用处： 设置常数 设置后续C指令阶段要操纵的数据存储器的地址 设置后续C指令阶段要操纵的指令存储器的地址 C指令决定计算机的所有可能操作。指令有3个部分，解决3个问题，计算什么（comp），在哪里存储被计算的值（dest），下一步做什么（jump）。 C指令 comp部分这里出现的+、-等符号应作为助记符的一部分，而不是一种操作符（比如D+A可以当作ADD。。。？） comp dest部分 dest jump部分 jump A寄存器的冲突使用C指令中，A寄存器既可以用于访问数据存储器的M，也可以访问指令存储器。为了避免冲突，一条指令中A寄存器不能同时使用这2种用法。 符号（Symbols）在汇编语言中，访问一个内存地址，可以使用常数或者符号。 符号有以下3种： 预定义符号（Predefined symbols）RAM的一部分地址可以用预定义符号指定。 虚拟寄存器（Virtual registers）：用R0~R15指定RAM[0]~RAM[15]。 预定义指针（Predefined pointers）：用SP、LCL、ARG、THIS、THAT指定RAM[0]~RAM[4]。 I/O指针（I/O pointers）：用SCREEN、KBD指定RAM[16384]（RAM[0x4000]）和RAM[24576]（RAM[0x6000]），这是屏幕和键盘的内存映射的基地址。 标记符号（Label symbols）用户定义的用于表示goto的目的地址的符号，用伪命令“(Xxx)”来声明。 变量符号（Variable symbols）用户定义的符号Xxx，Xxx不是预定义符号和标记符号，那么就是一个变量，汇编器会分配一个唯一的内存地址，从RAM[0x0010]开始。 输入/输出处理（Input/Output Handling）Hack有2个外设（peripheral devices），屏幕和键盘。它们通过内存映射（memory maps）来交互。物理I/O设备和内存映射通过持续的刷新循环来同步。 屏幕256行、每行512个像素的黑白的屏幕。从RAM[0x4000]开始有8K words的内存映射，从左上角开始一个位代表一个像素，1=black，0=white。第r行第c列的像素被映射到RAM[0x4000+r*32+c/16]个word的第c%16位（从LSB到MSB）。 键盘只有RAM[0x6000]一个word的内存映射，某按键被按下，这里存的就是ASCII码，没有按键按下就是0。 其他的按键对应的数字： 键码 语法约定和文件格式（Syntax Conventions and File Format）二进制文件（Binary code files）扩展名为hack。一行一个16位01串，指定一个机器语言指令。 汇编文件（Assembly language files）扩展名为asm。 每行为一个Instruction或者 (Symbol)。 常量非负且为10进制，用户定义的符号可以是字母、数字、下划线（_）、点（.）、美元符号（$）、冒号（:），不能以数字开头。 //后为单行注释。 约定标记名大写，变量名小写。 项目这次使用2个新的工具，汇编器和CPU模拟器。 下载 汇编器的使用说明 CPU模拟器的使用说明 project要求用汇编语言编写2个程序。 乘法程序（Mult.asm）：实现R0乘R1，结果放在R2。 I/O处理程序（Fill.asm）：按下任意按键屏幕变黑，否则变白。 （我的代码见github","categories":[{"name":"课程","slug":"课程","permalink":"https://4eay7lab.com/categories/课程/"}],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"https://4eay7lab.com/tags/计算机系统/"},{"name":"nand2tetris","slug":"nand2tetris","permalink":"https://4eay7lab.com/tags/nand2tetris/"},{"name":"本科补全","slug":"本科补全","permalink":"https://4eay7lab.com/tags/本科补全/"}]},{"title":"nand2tetris ch3 时序逻辑","slug":"nand2tetris-3","date":"2019-07-06T16:00:03.000Z","updated":"2020-10-26T07:31:31.405Z","comments":true,"path":"2019/07/07/nand2tetris-3/","link":"","permalink":"https://4eay7lab.com/2019/07/07/nand2tetris-3/","excerpt":"","text":"概述1、2章的芯片都是组合逻辑电路（Combinational logic circuit），输出只取决于输入，不能保持状态。 时序逻辑电路（Sequential logic circuit）不仅能计算值，而且能够存储值（存在反馈回路）。 组合逻辑和时序逻辑 存储器的实现涉及到同步、计时、反馈回路，最基础的时序电路芯片是触发器（Flip-flop），通过它可以构建出计算机系统的存储设备。当然现代计算机的存储器不总是用FF造的，现代存储芯片总是利用存储技术的基础物理特性实现最优化，用哪种技术取决于性价比。 时钟（Clock）在大多数计算机中，时间的流逝是通过一个主时钟（Master clock）传递一个连续的交流信号来表示的。 硬件实现是基于一个有源晶振 或 振荡器（英文Oscillator，内部有时钟电路，供电即可产生振荡信号。还有一种无源晶振或谐振器，英文为Crystal，需要借助时钟电路产生振荡信号。硬件模拟器中需要用户或脚本实现），它会交替产生高低电平，一个0-1（或者 low-high/tick-tock）为一个周期（Cycle），每一个时钟周期是一个单位时间。 这个信号被同时广播到计算机的每一个时序芯片上。 触发器（Flip-flop）它是最基础的时序电路芯片，有多种变种，这里使用的是DFF（Data flip-flop，这里用到的似乎是下降沿触发的。。）。一位数据输入，一个时钟输入（信号来自主时钟），一位数据输出，实现$out(t)=in(t-1)$。 寄存器（Register）1位的寄存器用DFF造一个1位的寄存器，也叫做Bit。 1 bit w位的寄存器 w bit 存储器随机存取存储器（RAM）读写操作要访问任意一个单元，访问的顺序没有限制，任意位置，访问速度一样。 输入包括，一个数据输入、一个地址输入、一个load位。 参数： 字长（data-width）：一个word多少位 字数（size）：多少个words RAMn RAMn 存储器的递归构建 存储器的递归构建 计数器（Counter）每个时间单位输出都有一个增量，$out(t)=out(t-1)+c$，c一般是1。通常计数器有一些额外的功能，可以从0或者某一个数（counting base）开始，可以是减少一个量。 比如，CPU的程序计数器（Program counter，简称PC） PC 消除组合逻辑中的冒险DFF使时序芯片保持一个状态或者改变一个状态，避免了组合电路的不可控的数据竞争（Data race）的影响。 在改变输入值时，由于一些物理限制（距离、阻碍、干扰、噪声等），几个输入值传输到芯片的时间不一样（数电上称为竞争。。），会使输出在一段时间内产生不正确的结果（数电上称为冒险。。）。 组合电路中输出只由输入控制，和时间无关，所以中间可能会出现不正确输出。 时序电路中的DFF保证输出只在进入一个新的时钟周期的一刻改变（其他时间是锁存的），也就是我们允许在一个周期内出现不稳定的状态，在下一个周期开始时是合法的状态。 所以消除冒险的方法是，时钟周期的时间比传输数据的时间稍长，保证时序芯片更新状态时的输入是合法的。由此实现系统硬件各个部分的同步来达到良好协调。 项目project依然是用之前造好的芯片来实现这一章的芯片（除了DFF）。（我的代码见github 这一章的DFF不用了解具体实现（详细内容见数电课程），相当于之前的Nand，这里直接拿来构造其它时序电路就行。 需要查看硬件模拟器使用说明的4-5部分，以及附录A6-7。 需要建造的芯片列表： Bit Register PC RAM8 RAM64 RAM512 RAM4K RAM16K","categories":[{"name":"课程","slug":"课程","permalink":"https://4eay7lab.com/categories/课程/"}],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"https://4eay7lab.com/tags/计算机系统/"},{"name":"nand2tetris","slug":"nand2tetris","permalink":"https://4eay7lab.com/tags/nand2tetris/"},{"name":"本科补全","slug":"本科补全","permalink":"https://4eay7lab.com/tags/本科补全/"}]},{"title":"nand2tetris ch2 布尔运算","slug":"nand2tetris-2","date":"2019-07-06T16:00:02.000Z","updated":"2020-10-26T07:31:31.405Z","comments":true,"path":"2019/07/07/nand2tetris-2/","link":"","permalink":"https://4eay7lab.com/2019/07/07/nand2tetris-2/","excerpt":"","text":"概述这一章要使用之前制造的基本逻辑门，来制造出算术逻辑单元（ALU），这个芯片执行计算机的所有的算术和逻辑运算，对于理解CPU和计算机很重要。 首先，要造一个加法器（adder），在此之前需要了解以下知识。 二进制数了解一下进制、进制转换，在此不总结。 二进制数加法和十进制加法类似，从LSB开始对应的位相加，一直加到MSB，若某一位产生进位1，则加到下一位，MSB如果产生了进位，就是溢出（overflow）。可以发现能由全加器构建。 有符号二进制数n位二进制系统可以产生$2^n$个不同的位模式。为了表示有符号二进制数，一个自然的方法是把空间分为2个大小相等的子集，一个子集表示正数，另一个子集表示负数。 有符号数的编码方式应当使得硬件实现尽量简单。现在常用的方法是二补数或补码（2’s complement，或基数为2的radix complement）。在n位二进制系统，一个数x的补码的定义如下： $\\overline{x}=\\begin{cases}2^n-x,&amp;x\\ne0 \\cr 0 ,&amp; otherwise\\end{cases}$ complement 可以发现补码表示的性质： 一个系统共可以表示$2^n$个有符号数，范围是$[-2^{n-1},2^{n-1}-1]$。 正数的MSB为0，负数的MSB为1。 由x得到-x的方法是，除了最低一位的1以及比它低位的0（lowbit？），每一位取反。还有一种硬件实施更简单的方法，所有位取反，然后加1。 补码表示的好处是有符号数的加法不需要特殊的硬件。2个有符号数相加，直接用它们的补码表示相加。2个有符号数相减，如x-y，相当于x+(-y)，即x的补码表示和-y的补码表示相加。 加法器（Adders）这里要知道3种 半加器（Half-adder）2个1位的数相加，不考虑低位的进位。 half adder 全加器（Full-adder）3个1位的数相加，c是来自低位的进位。 full adder 加法器（Adder）2个n位的数相加，这里n=16。这里实现直接用全加器串联。 adder 其它这里用的加法器的实现是模拟笔算，称为串行进位加法器，结构简单，然而运行速度慢，一般解决方法是使用超前进位加法器。 还有一种特殊目的的加法器，增量器（Incrementer），可以给1个数加1。 ALU这里介绍Hack使用的ALU，它计算$out=f_i(x,y)$，$f_i$是某种算术和逻辑运算，这里的$f_i$有18种。我们通过6个控制位（control bits）来控制使用的$f_i$。 ALU ALU真值表 这里没有乘法或者除法以及其他一些运算，这些运算会在OS一章实现。详细的布尔运算和ALU设计可以在其他计算机体系结构的书中找到。 项目project要求使用之前章节造好的芯片，实现一个ALU（我的代码见github 需要建造的芯片列表： HalfAdder FullAdder Add16 Inc16 ALU","categories":[{"name":"课程","slug":"课程","permalink":"https://4eay7lab.com/categories/课程/"}],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"https://4eay7lab.com/tags/计算机系统/"},{"name":"nand2tetris","slug":"nand2tetris","permalink":"https://4eay7lab.com/tags/nand2tetris/"},{"name":"本科补全","slug":"本科补全","permalink":"https://4eay7lab.com/tags/本科补全/"}]},{"title":"nand2tetris ch1 布尔逻辑","slug":"nand2tetris-1","date":"2019-07-06T16:00:01.000Z","updated":"2020-10-26T07:31:31.405Z","comments":true,"path":"2019/07/07/nand2tetris-1/","link":"","permalink":"https://4eay7lab.com/2019/07/07/nand2tetris-1/","excerpt":"","text":"概述基于物理学制造出晶体管，晶体管和电路构造出与非门（Nand），与非门（或者 或非门，它们是primitive gates，其它门都是composite gates）可以构造出与门、或门、非门，于是可构造出各种数字电路（任何布尔表达式都可以用与、或、非表示）。所以要构建计算机（课程中名为Hack，一个16位计算机），首先需要了解的是Nand相关的知识。 学习Nand前，先学习布尔代数、真值表、布尔表达式、范式，这些在此不做总结。 这里我们只关注一个芯片的外部接口（输入、输出），不关注具体实现。 基本逻辑门与门、或门、非门 and or not 异或门（Exclusive or） xor 数据选择器（Multiplexor） mux mux真值表 数据分配器（Demultiplexor） dmux dmux真值表 多位（Multi-bit）版本的基本门电路输入输出可能是多于1位的二进制数，按位做运算。 多路（Multi-way）版本的基本门电路有更多的输入输出针脚，实现类似操作。 硬件描述语言（HDL）现实生活中要生产芯片，需要电路要达到预期的功能，最快的速度，最少的花费，大多数人不会直接制造，而是会先在软件上模拟电路的运行。 课程提供了一个硬件模拟器。 下载 使用说明 HDL的编写和测试脚本的编写见书附录A、B。 项目project要求使用内建的Nand，编写HDL代码构造其他芯片（我的代码见github 需要运行硬件模拟器，查看其使用说明的1-3部分，以及附录A1-6。 需要建造的芯片列表： Not Not16 And And16 Or Or8Way Or16 DMux DMux4Way DMux8Way Mux Mux16 Mux4Way16 Mux8Way16 Xor","categories":[{"name":"课程","slug":"课程","permalink":"https://4eay7lab.com/categories/课程/"}],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"https://4eay7lab.com/tags/计算机系统/"},{"name":"nand2tetris","slug":"nand2tetris","permalink":"https://4eay7lab.com/tags/nand2tetris/"},{"name":"本科补全","slug":"本科补全","permalink":"https://4eay7lab.com/tags/本科补全/"}]},{"title":"nand2tetris ch0 介绍","slug":"nand2tetris-0","date":"2019-07-06T16:00:00.000Z","updated":"2020-10-26T07:31:31.404Z","comments":true,"path":"2019/07/07/nand2tetris-0/","link":"","permalink":"https://4eay7lab.com/2019/07/07/nand2tetris-0/","excerpt":"","text":"概述这是一门基于项目的自下而上构建计算机的有趣的课程。 按照以下层次自下而上讲解每一层的构建，每到一层只关心这一层的实现，不关注下面层次的具体实现。 总体不深入，比较浅显易懂。现代计算机体系结构中的2个重要的概念，流水线和存储层次，几乎没有涉及。 课程内容 典型计算机系统设计中的组成要素的抽象 相关资源本课程官网 coursera(硬件部分) coursera(软件部分) 配套书籍：The Elements of Computing Systems: Building a Modern Computer from First Principles 其它相关课程Berkeley’s CS61C 计组最经典的还是这本 _(:°з」∠)_：Computer Organization and Design MIPS Edition: The Hardware/Software Interface (The Morgan Kaufmann Series in Computer Architecture and Design) 其它笔记blog中会进行关键知识的总结记录。目标是完成前6章。 已经完成的章节： ch1 布尔逻辑 ch2 布尔运算 ch3 时序逻辑 ch4 机器语言 ch5 计算机体系结构 ch6 汇编器 项目我的projects解决方案","categories":[{"name":"课程","slug":"课程","permalink":"https://4eay7lab.com/categories/课程/"}],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"https://4eay7lab.com/tags/计算机系统/"},{"name":"nand2tetris","slug":"nand2tetris","permalink":"https://4eay7lab.com/tags/nand2tetris/"},{"name":"本科补全","slug":"本科补全","permalink":"https://4eay7lab.com/tags/本科补全/"}]},{"title":"NEW log!","slug":"hello-world","date":"2019-07-05T16:00:00.000Z","updated":"2020-10-26T07:31:31.404Z","comments":true,"path":"2019/07/06/hello-world/","link":"","permalink":"https://4eay7lab.com/2019/07/06/hello-world/","excerpt":"","text":"记录2019-7-6从wp迁移到jekyll 2019-8-5~2019-8-7由于一些jekyll的缺点，从jekyll迁回hexo 2019-12-31添加了置顶 其它oi/icpc题解传送门","categories":[{"name":"其它","slug":"其它","permalink":"https://4eay7lab.com/categories/其它/"}],"tags":[{"name":"记录","slug":"记录","permalink":"https://4eay7lab.com/tags/记录/"}]}]}